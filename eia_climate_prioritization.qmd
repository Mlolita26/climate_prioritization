---
title: "CGIAR EiA Climate Adaptation Prioritization Tool"
author: "Peter Steward, Harold Achicanoy, Todd Rosenstock, Brayden Youngberg, Lolita Muller and Petra Schimitter"
format:
  html:
    embed-resources: true
    page-layout: full
    grid:
      body-width: 1800px
bibliography: references/refs.bib
execute:
  echo: true
server: shiny
---
<!-- 
```{=html}
<style>
  .main-container {
    max-width: 1800px;
    margin-left: auto;
    margin-right: auto;
  }
</style>
``` -->
::: {.panel-tabset .tabset-fade .tabset-pills}

### Introduction

This interactive Markdown document is designed to support the prioritization of climate adaptation investments at the regional level for CGIAR science programs. It accompanies a publication and provides an interactive interface for exploring the intersection of climate hazards and agricultural exposure. The primary goal is to aid decision-makers in identifying and prioritizing regions and crops most vulnerable to climate risks.

In addition to its specific application for CGIAR programs, this codebase is built to be fully repeatable and customizable, enabling adaptation for other purposes or regions. By incorporating flexible input datasets and scalable hazard combinations, the tool is suited to a wide range of agricultural and environmental risk assessments.

#### Structure of the Interactive Tool

This document consists of three main sections:

1. **Hazard Exposure Visualization**  
   This section provides an interactive visualization of climate hazards and their overlap with agricultural exposure. Users can explore the contributions of individual hazards to total exposure across crops and regions through customizable visualizations.

2. **Datasets**  
   This section lists all datasets used in the analysis, including a brief description, source information, variables included, resolution, and temporal coverage.

3. **Methods**  
   This section provides a detailed explanation of the methodology used to process climate hazard data, classify them into binary risk categories, and combine them with agricultural exposure data for analysis.

The tool empowers users to dynamically adjust parameters, such as the selection of crops, regions, or hazard thresholds, providing a customizable framework for climate risk analysis.

---

#### Acknowledgments

This work was funded by the CGIAR Excellence in Agronomy Initiative as part of the climate add-on led by Dr Petra Schmitter. The concept for this work is lead by Dr Todd Rosenstock (Climate Action, Alliance of Bioversity International and CIAT (ABC)). The development of this script is led by Dr Peter Steward & Brayden Youngberg (Climate Action, ABC). Harold Achicanoy (Climate Action, ABC) contributed the CHIRPS rainfall CV and AgERA5 heat stress climate datasets.

If you are interested in Africa-specific hazard x exposure x vulnerability/adaptive capacity spatial prioritization data and potential solutions to mitigate climate risks, please visit the [Africa Agricultural Adaptation Atlas (AAAA)](https://adaptationatlas.cgiar.org/).

#### Contact

For questions or further information, please contact:  
- Peter Steward: [p.steward@cgiar.org](mailto:p.steward@cgiar.org)  
- Brayden Youngberg: [b.youngberg@cgiar.org](mailto:b.youngberg@cgiar.org)  
- Todd Rosenstock: [t.rosenstock@cgiar.org](mailto:t.rosenstock@cgiar.org)

<div style="text-align: center; margin-top: 30px;">
  <img src="logos/abc.png" alt="Logo 1" height="100" style="margin: 10px;">
  <img src="logos/eia.png" alt="Logo 2" height="100" style="margin: 10px;">
  <img src="logos/cgiar.jpeg" alt="Logo 3" height="100" style="margin: 10px;">
</div>

### Hazard Exposure Visualization
```{r setup, include=FALSE}
options(scipen = 999)
```

```{r Load packages,echo=F,message=F,warning=F}
#| context: setup
library(nanoparquet)
library(DT)
library(colourpicker)
library(data.table)
library(dplyr)
library(ggplot2)
library(ggpubr)
library(MetBrewer)
library(reshape)
library(shiny)
library(viridis)
library(wesanderson)

if(!require("waffle")){
  devtools::install_github("hrbrmstr/waffle")
  require("waffle")
}
 
```

```{r Palette,echo=F}
#| context: setup

Viridis<-data.table(Source="viridis",Palette=c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"))
Met<-data.table(Source="MetBrewer",Palette=names(MetBrewer::MetPalettes))
Wes<-data.table(Source="wesanderson",Palette=names(wesanderson::wes_palettes))

Palettes<-rbind(Viridis,Met)

PalFun<-function(PalName,N,Names) {
Viridis<-data.table(Source="viridis",Palette=c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"))
Met<-data.table(Source="MetBrewer",Palette=names(MetBrewer::MetPalettes))
Palettes<-rbind(Viridis,Met)
    
 if(Palettes[Palette==PalName,Source]=="viridis"){
    PAL<-viridis::viridis(N,option=PalName)
 }

if(Palettes[Palette==PalName,Source]=="MetBrewer"){
     PAL<-MetBrewer::met.brewer(name=PalName, n=N, type="continuous")
}

  if(Palettes[Palette==PalName,Source]=="Wes"){
     PAL<-wesanderson::wes_palette(name=PalName, n=N, type="continuous")
  }
names(PAL)<-Names

return(PAL)
}
```

```{r load mapspam, echo =F}
#| context: setup
haz_ex_file<-"Data/hazard_ex_admin.parquet"

Data<-data.table(nanoparquet::read_parquet(haz_ex_file))
# default variable selection
var_choice<-"vop"
```

```{r Create Plot Save Location,echo=F}
PlotDir<-"Plots"
if(!dir.exists(PlotDir)){
  dir.create(PlotDir)
}

```


```{r Choose variable,echo=F}
cg_regions <- Data[, sort(unique(Region))]
Regions <- cg_regions[cg_regions %in% c("Africa", "LAC", "SA", "SEA")]

tags$div(style = "display: flex;",
      selectInput(
        inputId = "var_choice",
        label = "Choose spam variable",
        choices = Data[, unique(variable)],
        selected = var_choice,
        multiple = FALSE,
        width = "150px"
      ),
      selectizeInput(
  inputId = "Regions",
  label = "Select Regions:",
  choices = cg_regions,
  selected = Regions,  # Pre-selected regions
  multiple = TRUE,     # Allow multi-selection
  options = list(
    plugins = list('remove_button'),  # Add remove button (small "x") for each selected item
    placeholder = 'Click to select or type to search...',  # Add a user-friendly placeholder
    onDelete = I("function() { console.log('Item deleted'); }")  # Optional: log or perform an action when an item is removed
  )
)
    )

```


```{r choose country, echo=F}
#| context: server
# Dynamically filter countries based on selected regions
output$Countries <- renderUI({
  req(input$Regions) # Ensure regions are selected

   selectizeInput(
    inputId = "Countries",  # Correct inputId to "Countries"
    label = "Select Countries:",
    choices = Data[!is.na(Country) & Country != "" & Region %in% input$Regions, sort(unique(Country))],
    selected = NULL,
    multiple = TRUE,  # Allow multi-selection
    options = list(
      plugins = list('remove_button'),  # Add remove button (small "x") for each selected item
      placeholder = 'Click to select or type to search...'  # Add a user-friendly placeholder
    )
  )  
})
```

```{r, echo=F}
uiOutput("Countries")
```
```{r choose crops 2,echo=F}
#| context: server
crop_options<-reactive({
  if(is.null(input$Countries)){
    Data[Region %in% input$Regions & (is.na(Country)|Country==""),sort(unique(Crop))]
  }else{
    Data[Region %in% input$Regions & Country %in% input$Countries,sort(unique(Crop))]
  }
})

output$crops <- renderUI({
  selectizeInput(inputId="crops", 
                     label="Choose Crops",
                     choices = crop_options(),
                     selected = crop_options(),
                     width="1200px",
                     multiple = TRUE,  # Allow multi-selection
    options = list(
      plugins = list('remove_button'),  # Add remove button (small "x") for each selected item
      placeholder = 'Click to select or type to search...'  # Add a user-friendly placeholder
    ))
  })

```

```{r, echo=F}
uiOutput("crops")
```



```{r set default parameter values,echo=F}
Scaler<-200
NRows<-15
NRows2<-2
FacetRows<-1
TextSize<-20
TextWrap<-"No"
RmNoHaz<-"Yes"
LegPos<-"bottom"
PanelSpace<-0
GridSpace<-0.3
GridCols<-2
GridRows<-3
Palette<-"turbo"
Background<-"white"
GridCol<-"white"
NoHazardCol<-"grey50"
Plot.Height<-0.3
Plot.Width<-1.2
p3_free<-"fixed"
p3_order_val<-"Yes"
p3_unit<-"Billion"
Crop.N1<-5
Crop.N2<-20
Crop.N3<-Data[,length(unique(Crop))]
n_haz<-10
```

```{r Choose Plot,echo=F}

tags$div(
  style = "border: 2px solid #007BFF; border-radius: 10px; padding: 15px; background-color: #F8F9FA; margin-top: 20px;",
  
  h3(style = "color: #007BFF;", "Choose and Understand Plot Types"),
  
  p("Select a plot type to visualize hazard and exposure data. The options include:"),
  
  tags$ul(
    tags$li(strong("Plot 1:"), " Displays waffle charts for the top crops in selected regions."),
    tags$li(strong("Plot 2:"), " Aggregates hazard exposure into compact waffle grids for all crops."),
    tags$li(strong("Plot 3:"), " Stacked bar charts showing cumulative hazard exposure across crops.")
  ),
  
  # Input controls combined into one div
  tags$div(
    style = "display: flex; flex-wrap: wrap; gap: 15px; align-items: center; margin-top: 10px;",
    
    # Plot type selector with user-friendly labels
    selectInput(
      inputId = "plot_choice", 
      label = strong("Select Plot Type"),
      choices = c("Top Crops Waffle" = "plot1",
                  "Compact Waffle Grid" = "plot2",
                  "Stacked Bars" = "plot3"),
      selected = "plot3", 
      multiple = FALSE, 
      width = "300px"
    ),
    
    # Palette selection
    selectInput(
      inputId = "Palette", 
      label = strong("Choose Color Palette"),
      choices = Palettes[,sort(Palette)],
      selected = "turbo", 
      multiple = FALSE, 
      width = "200px"
    ),
    
    # Color inputs
    colourInput(
      inputId = "Background",
      label = "Background Colour",
      value = Background
    ),
    colourInput(
      inputId = "GridCol",
      label = "Grid Colour",
      value = GridCol
    ),
    colourInput(
      inputId = "NoHazardCol",
      label = "No Hazard Colour",
      value = NoHazardCol
    )
  )
)


```


```{r Scaling factor, echo=F}
# Place this at the **beginning** of your UI where inputs are needed

actionButton("show_customize", label = "➤ Customize Chart Display", 
             style = "background-color: #007BFF; color: white; font-weight: bold; border-radius: 5px; padding: 5px 15px;")

# Collapsible Panel
tags$div(
  id = "customize_panel", 
  style = "display: none; border: 2px solid #007BFF; border-radius: 10px; padding: 15px; background-color: #F8F9FA; margin-top: 20px;",
  
  h3(style = "color: #007BFF; text-align: center;", "Customize Chart Display"),
  
  # General Layout Controls
  tags$div(
    style = "display: flex; flex-wrap: nowrap; gap: 20px; margin-bottom: 15px;",
    numericInput("Scaler", "Max Blocks (Size Scaling)", value = Scaler, min = 0, max = 2000, step = 50, width = "250px"),
    numericInput("TextSize", "Text Size", value = 20, min = 1, max = 30, step = 1, width = "120px"),
    selectInput("TextWrap", "Wrap Labels?", choices = c("Yes", "No"), selected = TextWrap, width = "120px"),
    selectInput("RmNoHaz", "Remove 'No Hazard'?", choices = c("Yes", "No"), selected = RmNoHaz, width = "250px"),
    selectInput("LegPos", "Legend Position", choices = c("bottom", "right", "top", "left"), selected = LegPos, width = "150px")
  ),

  # Grid and Facet Settings
  tags$div(
    style = "display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 15px;",
    numericInput("NRows", "Waffle Columns (Plot 1)", value = 25, min = 1, max = 30, step = 1, width = "200px"),
    numericInput("NRows2", "Waffle Columns (Plot 2)", value = NRows2, min = 1, max = 30, step = 1, width = "200px"),
    numericInput("FacetRows", "Number of Facet Rows", value = FacetRows, min = 1, max = 30, step = 1, width = "200px"),
    numericInput("PanelSpace", "Facet Spacing", value = PanelSpace, min = 1, max = 30, step = 1, width = "150px"),
    numericInput("GridSpace", "Grid Spacing", value = GridSpace, min = 0, max = 3, step = 0.01, width = "150px")
  ),
  
  tags$div(
  style = "display: flex;",
      numericInput(
        inputId = "Crop.N1",
        label = "No. of crops to show (plot1)",
        value = Crop.N1,
        min = 1,
        max = Data[, length(unique(Crop))],
        step = 1,
        width = "300px"
      ),
      numericInput(
        inputId = "Crop.N2",
        label = "No. of rows to show (plot2)",
        value = Crop.N2,
        min = 1,
        max = 50,
        step = 1,
        width = "300px"
      ),
      numericInput(
        inputId = "Crop.N3",
        label = "No. of crops to show (plot3)",
        value = Crop.N3,
        min = 1,
        max = Data[, length(unique(Crop))],
        step = 1,
        width = "300px"
      ),
      numericInput(
        inputId = "Haz.N",
        label = "No. of hazards to show",
        value = n_haz,
        min = 1,
        max = Data[, length(unique(Hazard))],
        step = 1,
        width = "300px"
    )
  ),

  # Grid Layout Settings
  tags$div(
    style = "display: flex; flex-wrap: wrap; gap: 15px;",
    numericInput("GridCols", "Grid Columns", value = GridCols, min = 1, max = 10, step = 1, width = "150px"),
    numericInput("GridRows", "Grid Rows", value = GridRows, min = 1, max = 10, step = 1, width = "150px"),
    selectInput("p3_free", "Y-Axis Scaling", choices = c("Free" = "free", "Fixed" = "fixed"), selected = p3_free, width = "150px"),
    selectInput("p3_order_val", "Order by Value?", choices = c("Yes" = "Yes", "No" = "No"), selected = p3_order_val, width = "150px")
  ),


tags$div(
    style = "display: flex; flex-wrap: nowrap; gap: 20px; margin-top: 15px;",
    numericInput("Plot.Height", "Adjust Plot Height", value = Plot.Height, min = 0.1, max = 3, step = 0.05, width = "200px"),
    numericInput("Plot.Width", "Adjust Plot Width", value = Plot.Width, min = 0.1, max = 3, step = 0.1, width = "200px"),
    selectInput("p3_unit", "P3 VoP Unit", choices = c("Thousand", "Million", "Billion"), selected = p3_unit, width = "150px")
  )
)

# JavaScript to Toggle Panel Visibility
tags$script(HTML("
  $(document).ready(function(){
    $('#show_customize').on('click', function(){
      $('#customize_panel').slideToggle('fast');
    });
  });
"))

```

```{r calculate units, echo=F}
#| context: server
dat<-reactive({
  req(input$Regions)
  req(input$var_choice)
  req(input$crops)

  if(is.null(input$Countries)){
    dat<-Data[Region %in% input$Regions & (Country==""|is.na(Country)) & Crop %in% input$crops & variable==input$var_choice]
  }else{
    dat<-Data[Country %in% input$Countries & Crop %in% input$crops & variable==input$var_choice]
  }

  # Reduce number of hazards
  n_haz<-input$Haz.N
  haz_rank<-dat[Hazard!="none",.(value=sum(value,na.rm=T)),by=Hazard][order(value,decreasing = T)][,rank:=1:.N]
  haz_choice<-haz_rank[grep("[(]",Hazard),Hazard]
  n_haz<-n_haz-length(haz_choice)
  if(n_haz>0){
  haz_choice<-c(haz_choice,haz_rank[!grepl("[(]",Hazard),Hazard][1:n_haz])
  }
  dat<-dat[!Hazard %in% c(haz_choice,"none") & !is.na(Hazard),Hazard:="other combination"]
  
  dat<-dat[,.(value=sum(value,na.rm=T)),by=.(Hazard,value_tot_crop,Region,Country,Admin,Crop,variable)]
    
  # Add ranks
  rank2<-unique(dat[order(value_tot_crop,decreasing = T),.(value_tot_crop,Region,Country,Crop)])[,Rank2:=1:.N]
  dat<-merge(dat,rank2,by=c("Region","Crop","Country","value_tot_crop"),all.x=T,sort=F)
  rank<-unique(dat[order(Region,Country,value_tot_crop,decreasing = T),.(Region,Country,value_tot_crop,Crop)])[,Rank:=1:.N,by=.(Region,Country)]
  dat<-merge(dat,rank,by=c("Region","Crop","Country","value_tot_crop"),all.x=T,sort=F)
  dat
})

square_val<-reactive({
  req(dat())

  dat1<-copy(dat())
  ranks<-dat1[,sort(unique(Rank))]
  if(length(ranks)>input$Crop.N1){
  ranks<-ranks[1:input$Crop.N1]
    dat1<-dat1[Rank %in% ranks]
  }
  
  max_value<-10^(nchar(dat1[,max(value)])-2)
  dat1[,value:=value/max_value]
  scale_factor<-dat1[,max(value,na.rm = T)/input$Scaler]
  round(scale_factor*max_value/10^6,1)
})

square_val2<-reactive({
  req(dat())
  dat2<-copy(dat())
  ranks<-dat2[,sort(unique(Rank2))]
  if(length(ranks)>input$Crop.N2){
  ranks<-ranks[1:input$Crop.N2]
    dat2<-dat2[Rank2 %in% ranks]
  }
  max_value<-10^(nchar(dat2[,max(value)])-2)
  dat2[,value:=value/max_value]
  scale_factor<-dat2[,max(value,na.rm = T)/input$Scaler]
  round(scale_factor*max_value/10^6,1)
})

unit_x<-reactive({
  if(input$var_choice=="vop"){"IntD 2015"}else{"ha"}
})

```


```{r, echo=F}
#| context: server

output$unitText <- renderText({
  req(square_val())
  req(square_val2())
  req(unit_x())
  print(square_val())
  print(square_val2())
  print(unit_x())

  paste0("Plot 1: Waffle grid unit = ", square_val()," million ",unit_x(),". Plot 2: Waffle grid unit = ",square_val2()," million ",unit_x())
})

```

```{r, echo=F}
textOutput("unitText")
```

```{r create plot function, echo=F}
#| context: server
#https://rud.is/rpubs/building-waffle-charts.html 

Waffler<-function(data,
                  Crops,
                  Crop.N1,
                  Crop.N2,
                  Crop.N3,
                  Regions,
                  Countries,
                  Scaler,
                  NRows,
                  NRows2,
                  FacetRows,
                  TextSize,
                  HazardPalette,
                  LegPos,
                  PanelSpace,
                  TextWrap,
                  RmNoHaz,
                  Background,
                  NoHazardCol,
                  GridSpace,
                  GridCol,
                  p3_free,
                  p3_order_val,
                  p3_unit){
  
  if(TextWrap=="Yes"){
    data[,Crops:=gsub("oil crops","oil-crops",Crops)]
    data[!grepl(" ",Crop),Crop:=paste0(Crop,"\n")]
    data[,Crop:=gsub(" ","\n",Crop)]
  }

  if(RmNoHaz=="Yes"){
    data<-data[Hazard!="none"]
  }

  # Create combined names
  data[, Combined := paste0(Admin, ":", Crop)]
  data[, Combined := factor(Combined, levels = data[, .(Total = sum(value)), by = Combined][order(-Total), Combined])]
  
  # ylab
  variable<-data[,unique(variable)]
  if(variable=="vop"){
    spam_lab1<-paste0("Value of production (",p3_unit," $I 2015)")
    spam_lab2<-"Value of production"
  }
  
   if(variable=="ha"){
    spam_lab1<-paste0("Harvested area (",p3_unit,"ha)")
    spam_lab2<-"Harvested area"
  }
  
  # Data for plot 1
  ranks<-data[,sort(unique(Rank))]
  if(length(ranks)>Crop.N1){
  ranks<-ranks[1:Crop.N1]
    data1<-data[Rank %in% ranks]
  } 
  max_value<-10^(nchar(data1[,max(value)])-2)
  data1[,value:=value/max_value]
  scale_factor<-data1[,max(value,na.rm = T)/Scaler]
  data1[,value:=round(value/scale_factor,0)]
  MaxY<-data1[,list(Height=ceiling(sum(value)/NRows)),by=.(Region,Country,Crop)][,max(Height)]+1
  data1<-data1[value>0]
  
  # Data for plot 2
  ranks<-data[,sort(unique(Rank2))]
  if(length(ranks)>Crop.N2){
  ranks<-ranks[1:Crop.N2]
  data2<-data[Rank2 %in% ranks]
  }
  max_value<-10^(nchar(data2[,max(value)])-2)
  data2[,value:=value/max_value]
  scale_factor<-data2[,max(value,na.rm = T)/Scaler]
  data2[,value:=round(value/scale_factor,0)]
  data2<-data2[value>0]
  
  # Data for plot 3
  data3<-copy(data)
  if(p3_unit=="Million"){
  data3[,value:=value/10^6]
  }
  if(p3_unit=="Thousand"){
  data3[,value:=value/10^3]
  }
  if(p3_unit=="Billion"){
  data3[,value:=value/10^9]
  }

  # Legend Palettes
    hazards1<-data1[,sort(unique(Hazard))]
    hazards2<-data2[,sort(unique(Hazard))]
    hazards3<-data3[,sort(unique(Hazard))]

    HazardPalette1<-PalFun(PalName=HazardPalette,
                      N=length(hazards1),
                      Names=hazards1)
    
    HazardPalette2<-PalFun(PalName=HazardPalette,
                  N=length(hazards2),
                  Names=hazards2)
    
    HazardPalette3<-PalFun(PalName=HazardPalette,
              N=length(hazards2),
              Names=hazards2)
  
   if(RmNoHaz=="No"){
     N<-which(names(HazardPalette1)=="none")
     N1<-which(names(HazardPalette1)!="none")
     HazardPalette1[N]<-NoHazardCol
     HazardPalette1<-HazardPalette1[c(N,N1)]
     
     N<-which(names(HazardPalette2)=="none")
     N1<-which(names(HazardPalette2)!="none")
     HazardPalette2[N]<-NoHazardCol
     HazardPalette2<-HazardPalette2[c(N,N1)]    
     
    N<-which(names(HazardPalette3)=="none")
     N1<-which(names(HazardPalette3)!="none")
     HazardPalette3[N]<-NoHazardCol
     HazardPalette3<-HazardPalette3[c(N,N1)]   
   }
    
    data1[,Hazard:=factor(Hazard,levels = names(HazardPalette1))]
    data2[,Hazard:=factor(Hazard,levels = names(HazardPalette2))]
    data3[,Hazard:=factor(Hazard,levels = rev(names(HazardPalette3)))]

  # Plot 3
  gg_theme <- theme(
  text = element_text(size = TextSize),
  plot.margin = margin(0, 0, 0, 0, unit = "cm"), # Remove plot margin
  panel.spacing = unit(0, "pt"), # No space between panels
  legend.position =  LegPos,
  panel.background = element_rect(fill = Background),
  strip.background = element_blank(),
  strip.text.y.left = element_text(
    angle = 0,                # Horizontal strip labels
    hjust = 1,                # Align strip labels horizontally
    vjust = 0.5,              # Center vertically
    margin = margin(0, 0, 0, 0) # Remove strip margins
  ),
  panel.grid.minor =  element_blank(),
  panel.grid.major.y = element_blank()
  )
  
  crop_order<-data3[,.(value=sum(value,na.rm=T)),by=Crop][order(value,decreasing = T),Crop]

  if(p3_order_val=="Yes"){
    data3$Crop <- factor(data3$Crop, levels = rev(crop_order))
  }else{
    data3$Crop <- factor(data3$Crop, levels = rev(unique(data3$Crop)))
  }
  
  if(Crop.N3<length(crop_order)){
  p3_crops<-crop_order[1:Crop.N3]
  data3<-data3[Crop %in% p3_crops]
  }
  
  g3 <- ggplot(data3, aes(x = Crop, y = value, fill = Hazard)) +
  geom_bar(stat = "identity", position =  position_stack(reverse = F), color = GridCol,width=1) +
  scale_fill_manual(values = HazardPalette3, drop = FALSE) +
  facet_grid(. ~ Admin, switch = "y", drop = FALSE,scales = p3_free) +
  theme_minimal() +
  labs(x = NULL, y = spam_lab1) +
  gg_theme+
  scale_y_continuous(expand = c(0.003,0.01))+
  coord_flip()
  # plot(g3)
  
  # Plot 2
  gg_theme <- theme(
  text = element_text(size = TextSize),
  plot.margin = margin(0, 0, 0, 0, unit = "cm"), # Remove plot margin
  panel.spacing = unit(0, "lines"), # No space between panels
  axis.ticks = element_blank(),
  axis.line = element_blank(),
  legend.position.inside =  c(0.8, 0.2),
  panel.background = element_rect(fill = Background),
  strip.background = element_blank(),
  strip.text.y.left = element_text(
    angle = 0,                # Horizontal strip labels
    hjust = 1,                # Align strip labels horizontally
    vjust = 0.5,              # Center vertically
    margin = margin(r = 0, l = 0, unit = "pt") # Remove strip margins
  ),
  axis.text = element_blank(),
  axis.title = element_blank(),
  panel.grid = element_blank()
  )
    
  g2 <- ggplot(data2, aes(fill = Hazard, values = value)) +
  waffle::geom_waffle(n_rows = NRows2, size = GridSpace, colour = GridCol, flip = FALSE) +
  scale_fill_manual(values = HazardPalette2, drop = FALSE) +
  scale_x_continuous(expand = c(0.005,0))+
  scale_y_continuous(expand = c(0.02,0.02))+
  facet_grid(Combined ~ ., switch = "y") + # Use facet_grid with switched strips
  gg_theme

  # Plot 1
  gg_theme<-theme(text = element_text(size=TextSize),
                  title = element_text(size=TextSize*0.7),
                  panel.spacing = unit(PanelSpace,"lines"),
                  axis.ticks = element_blank(),
                  axis.line = element_blank(),
                  panel.background = element_rect(fill=Background),
                  strip.background = element_blank(),
                  strip.text = element_text(margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt")),
                  plot.margin = margin(0, 0, 0, 0, unit = "cm"), 
                  axis.text = element_blank(),
                  axis.title = element_blank(),
                  panel.grid = element_blank())
  
  admin<-data1[,sort(unique(Admin))]
  Plots<-lapply(admin,FUN=function(REG){
    
    Plot.Dat<-data1[Admin==REG]
    
    Plot.Dat[,Crop:=factor(Crop,levels = unique(Plot.Dat[,.(Crop,Rank)])[order(as.numeric(Rank)),Crop])]
  
  g<-ggplot(Plot.Dat,aes(fill = Hazard, values = value)) +
    expand_limits(x=c(0,0), y=c(0,0)) +
    coord_equal() +
    labs(fill = NULL, colour = NULL,title = REG) + 
    waffle::geom_waffle(n_rows = NRows, size = GridSpace, colour = GridCol, flip = TRUE)+
    gg_theme+
    scale_fill_manual(values=HazardPalette1,drop=F)+
    facet_wrap(~Crop, nrow = FacetRows, strip.position = "bottom")+
    scale_y_continuous(limits=c(0,MaxY),expand = c(0,0))
  
  g

  })
  
  names(Plots)<-admin

  return(list(Plot1=Plots,Plot2=g2,Plot3=g3))
}

```

```{r create plots,echo=F}
#| context: server
PlotData<-reactive({
  req(dat())
  Waffler(data=copy(dat()),
          Crops=input$crops,
          Crop.N1=input$Crop.N1,
          Crop.N2=input$Crop.N2,
          Crop.N3=input$Crop.N3,
          Regions=input$Regions,
          Countries=input$Countries,
          Scaler=input$Scaler,
          NRows=input$NRows,
          NRows2=input$NRows2,
          FacetRows=input$FacetRows,
          TextSize=input$TextSize,
          HazardPalette=input$Palette,
          LegPos=input$LegPos,
          PanelSpace=input$PanelSpace,
          TextWrap=input$TextWrap,
          RmNoHaz=input$RmNoHaz,
          Background=input$Background,
          NoHazardCol=input$NoHazardCol,
          GridSpace=input$GridSpace,
          GridCol=input$GridCol,
          p3_free=input$p3_free,
          p3_order_val=input$p3_order_val,
          p3_unit=input$p3_unit)
})

```

```{r Plot Size Adjust Functions , echo=F}
#| context: server
Plot.Height <- function(){
  x<-  input$Plot.Height*400*length(PlotData()$Plot1)
  if(input$plot_choice %in% c("plot2","plot3")){
  x<- input$Plot.Height*(50+input$Crop.N2*100)
  }
  return(x)
}

Plot.Width <- function(){
  input$Plot.Width*1200
}
```

```{r Plot waffles,echo=F}
#| context: server
output$main_plot <- renderPlot({
  if(input$plot_choice=="plot1"){

  plot_list<-PlotData()$Plot1
  
  combined_plots<-ggpubr::ggarrange(plotlist=plot_list, 
                    ncol=input$GridCols,
                    nrow=input$GridRows,
                    common.legend = T,
                    legend = input$LegPos)
  
  combined_plots

  }else{
      if(input$plot_choice=="plot2"){
     PlotData()$Plot2
      }else{
      PlotData()$Plot3
      }
  }
  },height= Plot.Height,width=Plot.Width)
```

```{r, echo=F}
plotOutput("main_plot")
```


```{r  Save Waffle Option, echo=F}
tags$div(
  style = "border: 2px solid #007BFF; border-radius: 10px; padding: 15px; background-color: #F8F9FA; margin-top: 20px;",

  # Section Title
  h3(style = "color: #007BFF; text-align: center; margin-bottom: 15px;", "Download Plot Settings"),
  
  # Input Controls for Plot Dimensions
  tags$div(
    style = "display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; margin-bottom: 15px;",
    numericInput(
      inputId = "Waffle.Width",
      label = "Width (mm)", 
      value = 180,
      min = 30,
      max = 300,
      step = 10,
      width = "200px"
    ),
    numericInput(
      inputId = "Waffle.Height",
      label = "Height (mm)", 
      value = 180,
      min = 30,
      max = 300,
      step = 10,
      width = "220px"
    ),
    numericInput(
      inputId = "Waffle.Scale",
      label = "Scaling Factor", 
      value = 1.8,
      min = 0.5,
      max = 4,
      step = 0.1,
      width = "200px"
    )
  ),

  # Download Button
  tags$div(
    style = "text-align: center;",
    downloadButton(
      outputId = "downloadWaffle", 
      label = "Download Plot", 
      style = "background-color: #007BFF; color: white; font-weight: bold; border-radius: 5px; padding: 10px 20px;"
    )
  ),

  # User Hint
  tags$p(
    style = "font-size: 12px; color: #555; text-align: center; margin-top: 10px;",
    "Click 'Download Plot' to save the figure with your selected settings."
  )
)


```

```{r Save Waffle, echo=F}
#| context: server
output$downloadWaffle <- downloadHandler(
  filename = function() {
    paste0(input$Waffle.Filename, ".png")
  },
  content = function(file) {
    if(input$Waffle.Save.Plot == "Yes"){
      ggsave(filename = file,
             plot = ggpubr::ggarrange(plotlist = PlotData(), 
                                      ncol = input$GridCols,
                                      nrow = input$GridRows, 
                                      common.legend = TRUE, 
                                      legend = input$LegPos),
             width = input$Waffle.Width / 25.4,  # Convert mm to inches
             height = input$Waffle.Height / 25.4,
             units = "in",
             scale = input$Waffle.Scale,
             dpi = 600,
             device = cairo_png)
    }
  }
)
```

#### Data used in the waffle plot
```{r Show Data,echo=F}
#| context: server
output$data_ref <- DT::renderDT({
  datatable(Data[,!c("Admin","Label","Rank","Rank2")][,Unit:=paste("I$ 2015")],
            caption="Crop hazard frequency x exposure data.",
            extensions = 'Buttons',
            filter = "top",
            options = list(dom = 'Blfrtip',
                           buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                           lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  
})
```

```{r, echo = F}
DTOutput("data_ref")
```

<div style="text-align: center; margin-top: 30px;">
  <img src="logos/abc.png" alt="Logo 1" height="100" style="margin: 10px;">
  <img src="logos/eia.png" alt="Logo 2" height="100" style="margin: 10px;">
  <img src="logos/cgiar.jpeg" alt="Logo 3" height="100" style="margin: 10px;">
</div>

### Methods

#### Overview

This section outlines the processing and analysis methods, including hazard classification, integration with crop exposure data, and how thresholds were applied to generate binary classifications for the final analysis.

#### Hazard Classification

Each hazard was classified into two categories (presence or absence) based on predefined thresholds derived from processed data. Hazards were extracted specifically for rainfed or irrigated crop calendars to align with seasonal agricultural activities.

- **Rainfall Variability (CHIRPS)**  
  - **Description**: Coefficient of Variation (CV) measures the ratio of standard deviation to mean rainfall. It indicates how consistently rainfall is distributed over time, with higher values suggesting greater variability.  
  - **Data**: Mean CV of annual rainfall calculated for 2010–2023 [@chirps_article].  
  - **Threshold**:  
    - CV ≤ 20%: No significant rainfall variability.  
    - CV > 20%: Presence of moderate or higher rainfall variability (classified as "variability present").  

- **Flood Hazard (JRC 20-Year Return Period)**  
  - **Description**: Indicates depth of inundation during a significant flood event expected once every 20 years. A binary classification highlights whether any risk is present.  
  - **Data**: Flood hazard data derived from the JRC Global Flood Hazard Map [@flood_risk_data; @flood_risk_article].  
  - **Threshold**:  
    - Value = 0 cm: No flood hazard.  
    - Value > 0 cm: Presence of flood hazard.  

- **Drought Risk (Global Drought Observatory)**  
  - **Description**: Derived from a drought severity index calculated using remote sensing data. The index measures soil moisture anomalies. [@gdo_article; @gdo_data].  
  - **Threshold**:  
    - Index ≤ 1: No significant drought risk.  
    - Index > 1: Presence of medium or higher drought risk.  
  - **Details**: Drought risk was extracted for rainfed and irrigated crop calendars to align with growing seasons.  

- **Heat Stress (AgERA5)**  
  - **Description**: Represents the seasonal frequency of moderate or higher heat stress, where moderate stress is defined as >10 extreme heat days per month (temperature >35°C) [@agera5_data; @agera5_cat].  
  - **Temporal Resolution**: Monthly data.  
  - **Calculation**:  
    - For each cropping season, the mean monthly heat stress days were calculated and classified according the 10 day threshold. The proportion of seasons with heat hazards present was calculated across the timeseries.   
    - If the timeseries proportion exceeded 0.2 (indicating a 1 in 5 chance of experiencing heat stress), the area was classified as having significant heat stress.  
  - **Threshold**:  
    - Seasonal Frequency ≤ 0.2: No heat hazard.  
    - Seasonal Frequency > 0.2: Heat hazard present.  

- **Growing Season Reduction (GAEZ)**  
  - **Description**: The percentage change in the length of growing periods (LGP) under future climate scenario (rcp 2.6 2050) to historical baselines was calculated [@gaez_data; @gaez_methods].  
  - **Threshold**:  
    - Reduction < 10%: No significant reduction.  
    - Reduction ≥ 10%: Significant reduction.  

#### SPAM Exposure Data

- **Global SPAM (IFPRI)**:  
  - A global spatial production allocation model providing estimates of crop-specific production and harvested area [@mapspam_article; @mapspam_data].  

- **Africa-Specific SPAM (AAAA)**:  
  - Higher-resolution data for subnational crop production and harvested area across Africa, commissioned by the Africa Agricultural Adaptation Atlas.  

- **Integration**:  
  - Africa-specific SPAM data replaced corresponding IFPRI SPAM values to improve regional accuracy.  
  - Final combined dataset included high-resolution exposure for Africa and global data coverage elsewhere.  

#### Outputs

The resulting outputs include:  
- Combined hazard maps for rainfed and irrigated systems.  
- Tabulated hazard x exposure data aggregated by region, country, and crop.

<div style="text-align: center; margin-top: 30px;">
  <img src="logos/abc.png" alt="Logo 1" height="100" style="margin: 10px;">
  <img src="logos/eia.png" alt="Logo 2" height="100" style="margin: 10px;">
  <img src="logos/cgiar.jpeg" alt="Logo 3" height="100" style="margin: 10px;">
</div>

### Datasets

```{r display-dataset-table, echo=FALSE}
# Load dataset descriptor from CSV
dataset_info <- data.table::fread("Data/data_descriptor.csv", showProgress = FALSE)

# Render the dataset table
datatable(
  dataset_info,
  caption = "Table: Overview of datasets used in the analysis, including details on variables, timeframes, and formats.",
  extensions = 'Buttons',
  options = list(
    dom = 'Blfrtip',
    buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
    pageLength = 10,
    scrollX = TRUE,  # Enable horizontal scrolling
    autoWidth = FALSE,  # Prevent automatic resizing
    columnDefs = list(
      list(width = '150px', targets = 0),  # First column
      list(width = '200px', targets = 1,className = "text-truncate"),  # Second column with wrapping
      list(width = '150px', targets = 2),  # Third column
      list(width = '150px', targets = 3),  # Fourth column
      list(width = '150px', targets = 4),  # Fifth column
      list(width = '150px', targets = 5)   # Sixth column
    )
  ),
  class =  "nowrap stripe hover compact"
)
```

<div style="text-align: center; margin-top: 30px;">
  <img src="logos/abc.png" alt="Logo 1" height="100" style="margin: 10px;">
  <img src="logos/eia.png" alt="Logo 2" height="100" style="margin: 10px;">
  <img src="logos/cgiar.jpeg" alt="Logo 3" height="100" style="margin: 10px;">
</div>

### References

::: {#refs}
:::


:::
